defmodule Qx.Export.OpenQASMTest do
  use ExUnit.Case
  doctest Qx.Export.OpenQASM

  alias Qx.Export.OpenQASM

  describe "to_qasm/2 version validation" do
    test "accepts version 2" do
      circuit = Qx.create_circuit(1)
      assert is_binary(OpenQASM.to_qasm(circuit, version: 2))
    end

    test "accepts version 3" do
      circuit = Qx.create_circuit(1)
      assert is_binary(OpenQASM.to_qasm(circuit, version: 3))
    end

    test "raises on invalid version" do
      circuit = Qx.create_circuit(1)

      assert_raise ArgumentError, ~r/Invalid OpenQASM version/, fn ->
        OpenQASM.to_qasm(circuit, version: 1)
      end
    end

    test "defaults to version 3" do
      circuit = Qx.create_circuit(1)
      qasm = OpenQASM.to_qasm(circuit)
      assert qasm =~ "OPENQASM 3.0;"
    end
  end

  describe "to_qasm/2 header generation" do
    test "generates correct header for version 3" do
      circuit = Qx.create_circuit(2, 2)
      qasm = OpenQASM.to_qasm(circuit, version: 3)

      assert qasm =~ "OPENQASM 3.0;"
      assert qasm =~ "include \"stdgates.inc\";"
      assert qasm =~ "qubit[2] q;"
      assert qasm =~ "bit[2] c;"
    end

    test "generates correct header for version 2" do
      circuit = Qx.create_circuit(2, 2)
      qasm = OpenQASM.to_qasm(circuit, version: 2)

      assert qasm =~ "OPENQASM 2.0;"
      assert qasm =~ "include \"qelib1.inc\";"
      assert qasm =~ "qreg q[2];"
      assert qasm =~ "creg c[2];"
    end

    test "includes comments when requested" do
      circuit = Qx.create_circuit(1)
      qasm = OpenQASM.to_qasm(circuit, version: 3, include_comments: true)

      assert qasm =~ "// Generated by Qx"
    end
  end

  describe "to_qasm/2 single-qubit gates" do
    test "exports Hadamard gate" do
      circuit = Qx.create_circuit(1) |> Qx.h(0)
      qasm = OpenQASM.to_qasm(circuit)

      assert qasm =~ "h q[0];"
    end

    test "exports Pauli X gate" do
      circuit = Qx.create_circuit(1) |> Qx.x(0)
      qasm = OpenQASM.to_qasm(circuit)

      assert qasm =~ "x q[0];"
    end

    test "exports Pauli Y gate" do
      circuit = Qx.create_circuit(1) |> Qx.y(0)
      qasm = OpenQASM.to_qasm(circuit)

      assert qasm =~ "y q[0];"
    end

    test "exports Pauli Z gate" do
      circuit = Qx.create_circuit(1) |> Qx.z(0)
      qasm = OpenQASM.to_qasm(circuit)

      assert qasm =~ "z q[0];"
    end

    test "exports S gate" do
      circuit = Qx.create_circuit(1) |> Qx.s(0)
      qasm = OpenQASM.to_qasm(circuit)

      assert qasm =~ "s q[0];"
    end

    test "exports T gate" do
      circuit = Qx.create_circuit(1) |> Qx.t(0)
      qasm = OpenQASM.to_qasm(circuit)

      assert qasm =~ "t q[0];"
    end

    test "exports multiple gates in sequence" do
      circuit = Qx.create_circuit(1) |> Qx.h(0) |> Qx.x(0) |> Qx.z(0)
      qasm = OpenQASM.to_qasm(circuit)

      assert qasm =~ "h q[0];"
      assert qasm =~ "x q[0];"
      assert qasm =~ "z q[0];"
    end
  end

  describe "to_qasm/2 parameterized gates" do
    test "exports RX gate with parameter" do
      circuit = Qx.create_circuit(1) |> Qx.rx(0, :math.pi() / 2)
      qasm = OpenQASM.to_qasm(circuit)

      assert qasm =~ ~r/rx\([0-9.]+\) q\[0\];/
    end

    test "exports RY gate with parameter" do
      circuit = Qx.create_circuit(1) |> Qx.ry(0, :math.pi() / 4)
      qasm = OpenQASM.to_qasm(circuit)

      assert qasm =~ ~r/ry\([0-9.]+\) q\[0\];/
    end

    test "exports RZ gate with parameter" do
      circuit = Qx.create_circuit(1) |> Qx.rz(0, :math.pi())
      qasm = OpenQASM.to_qasm(circuit)

      assert qasm =~ ~r/rz\([0-9.]+\) q\[0\];/
    end

    test "exports Phase gate with parameter" do
      circuit = Qx.create_circuit(1) |> Qx.phase(0, :math.pi() / 2)
      qasm = OpenQASM.to_qasm(circuit)

      assert qasm =~ ~r/p\([0-9.]+\) q\[0\];/
    end

    test "formats parameters correctly" do
      circuit = Qx.create_circuit(1) |> Qx.rx(0, 1.5707963267948966)
      qasm = OpenQASM.to_qasm(circuit)

      # Check that parameter is formatted with proper precision
      assert qasm =~ "rx(1.5707963268) q[0];"
    end
  end

  describe "to_qasm/2 two-qubit gates" do
    test "exports CNOT gate" do
      circuit = Qx.create_circuit(2) |> Qx.cx(0, 1)
      qasm = OpenQASM.to_qasm(circuit)

      assert qasm =~ "cx q[0], q[1];"
    end

    test "exports CZ gate" do
      circuit = Qx.create_circuit(2) |> Qx.cz(0, 1)
      qasm = OpenQASM.to_qasm(circuit)

      assert qasm =~ "cz q[0], q[1];"
    end
  end

  describe "to_qasm/2 three-qubit gates" do
    test "exports Toffoli gate" do
      circuit = Qx.create_circuit(3) |> Qx.ccx(0, 1, 2)
      qasm = OpenQASM.to_qasm(circuit)

      assert qasm =~ "ccx q[0], q[1], q[2];"
    end
  end

  describe "to_qasm/2 measurements" do
    test "exports single measurement" do
      circuit = Qx.create_circuit(1, 1) |> Qx.h(0) |> Qx.measure(0, 0)
      qasm = OpenQASM.to_qasm(circuit)

      assert qasm =~ "c[0] = measure q[0];"
    end

    test "exports multiple measurements" do
      circuit =
        Qx.create_circuit(2, 2)
        |> Qx.h(0)
        |> Qx.cx(0, 1)
        |> Qx.measure(0, 0)
        |> Qx.measure(1, 1)

      qasm = OpenQASM.to_qasm(circuit)

      assert qasm =~ "c[0] = measure q[0];"
      assert qasm =~ "c[1] = measure q[1];"
    end
  end

  describe "to_qasm/2 barriers" do
    test "exports barrier on single qubit" do
      circuit = Qx.create_circuit(2) |> Qx.h(0) |> Qx.Operations.barrier([0]) |> Qx.x(0)
      qasm = OpenQASM.to_qasm(circuit)

      assert qasm =~ "barrier q[0];"
    end

    test "exports barrier on multiple qubits" do
      circuit = Qx.create_circuit(2) |> Qx.h(0) |> Qx.Operations.barrier([0, 1]) |> Qx.cx(0, 1)
      qasm = OpenQASM.to_qasm(circuit)

      assert qasm =~ "barrier q[0], q[1];"
    end
  end

  describe "to_qasm/2 conditional operations" do
    test "exports conditional gate in version 3" do
      circuit =
        Qx.create_circuit(2, 2)
        |> Qx.h(0)
        |> Qx.measure(0, 0)
        |> Qx.c_if(0, 1, fn c -> Qx.x(c, 1) end)

      qasm = OpenQASM.to_qasm(circuit, version: 3)

      assert qasm =~ ~r/if \(c\[0\] == 1\) \{ x q\[1\]; \}/
    end

    test "raises error for conditionals in version 2" do
      circuit =
        Qx.create_circuit(2, 2)
        |> Qx.h(0)
        |> Qx.measure(0, 0)
        |> Qx.c_if(0, 1, fn c -> Qx.x(c, 1) end)

      assert_raise Qx.ConditionalError, ~r/not supported in OpenQASM 2.0/, fn ->
        OpenQASM.to_qasm(circuit, version: 2)
      end
    end
  end

  describe "to_qasm/2 complex circuits" do
    test "exports Bell state circuit" do
      circuit =
        Qx.create_circuit(2, 2)
        |> Qx.h(0)
        |> Qx.cx(0, 1)
        |> Qx.measure(0, 0)
        |> Qx.measure(1, 1)

      qasm = OpenQASM.to_qasm(circuit)

      expected = """
      OPENQASM 3.0;
      include "stdgates.inc";

      qubit[2] q;
      bit[2] c;

      h q[0];
      cx q[0], q[1];
      c[0] = measure q[0];
      c[1] = measure q[1];
      """

      # Normalize whitespace for comparison
      normalize = fn s -> String.replace(s, ~r/\s+/, " ") |> String.trim() end

      assert normalize.(qasm) == normalize.(expected)
    end

    test "exports GHZ state circuit" do
      circuit =
        Qx.create_circuit(3, 3)
        |> Qx.h(0)
        |> Qx.cx(0, 1)
        |> Qx.cx(1, 2)
        |> Qx.measure(0, 0)
        |> Qx.measure(1, 1)
        |> Qx.measure(2, 2)

      qasm = OpenQASM.to_qasm(circuit)

      assert qasm =~ "h q[0];"
      assert qasm =~ "cx q[0], q[1];"
      assert qasm =~ "cx q[1], q[2];"
      assert qasm =~ "c[0] = measure q[0];"
      assert qasm =~ "c[1] = measure q[1];"
      assert qasm =~ "c[2] = measure q[2];"
    end

    test "exports quantum teleportation circuit" do
      circuit =
        Qx.create_circuit(3, 3)
        |> Qx.h(1)
        |> Qx.cx(1, 2)
        |> Qx.Operations.barrier([0, 1, 2])
        |> Qx.cx(0, 1)
        |> Qx.h(0)
        |> Qx.measure(0, 0)
        |> Qx.measure(1, 1)
        |> Qx.c_if(1, 1, fn c -> Qx.x(c, 2) end)
        |> Qx.c_if(0, 1, fn c -> Qx.z(c, 2) end)

      qasm = OpenQASM.to_qasm(circuit, version: 3)

      # Verify structure
      assert qasm =~ "h q[1];"
      assert qasm =~ "cx q[1], q[2];"
      assert qasm =~ "barrier q[0], q[1], q[2];"
      assert qasm =~ "cx q[0], q[1];"
      assert qasm =~ "h q[0];"
      assert qasm =~ "c[0] = measure q[0];"
      assert qasm =~ "c[1] = measure q[1];"
      assert qasm =~ ~r/if \(c\[1\] == 1\) \{ x q\[2\]; \}/
      assert qasm =~ ~r/if \(c\[0\] == 1\) \{ z q\[2\]; \}/
    end

    test "exports circuit with rotation gates" do
      circuit =
        Qx.create_circuit(2)
        |> Qx.rx(0, :math.pi() / 2)
        |> Qx.ry(1, :math.pi() / 4)
        |> Qx.cx(0, 1)
        |> Qx.rz(0, :math.pi())

      qasm = OpenQASM.to_qasm(circuit)

      assert qasm =~ ~r/rx\([0-9.]+\) q\[0\];/
      assert qasm =~ ~r/ry\([0-9.]+\) q\[1\];/
      assert qasm =~ "cx q[0], q[1];"
      assert qasm =~ ~r/rz\([0-9.]+\) q\[0\];/
    end
  end

  describe "to_qasm/2 error handling" do
    test "raises on unsupported gate" do
      # Create a circuit with a manually added unsupported instruction
      circuit = Qx.create_circuit(1)
      circuit = %{circuit | instructions: [{:unsupported_gate, [0], []}]}

      assert_raise Qx.GateError, ~r/Unsupported gate/, fn ->
        OpenQASM.to_qasm(circuit)
      end
    end
  end

  describe "to_qasm/2 version 2 compatibility" do
    test "exports simple circuit to version 2" do
      circuit =
        Qx.create_circuit(2, 2)
        |> Qx.h(0)
        |> Qx.cx(0, 1)
        |> Qx.measure(0, 0)
        |> Qx.measure(1, 1)

      qasm = OpenQASM.to_qasm(circuit, version: 2)

      assert qasm =~ "OPENQASM 2.0;"
      assert qasm =~ "include \"qelib1.inc\";"
      assert qasm =~ "qreg q[2];"
      assert qasm =~ "creg c[2];"
      assert qasm =~ "h q[0];"
      assert qasm =~ "cx q[0], q[1];"
      assert qasm =~ "c[0] = measure q[0];"
      assert qasm =~ "c[1] = measure q[1];"
    end
  end
end
