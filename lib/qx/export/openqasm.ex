defmodule Qx.Export.OpenQASM do
  @moduledoc """
  Export Qx quantum circuits to OpenQASM format.

  This module provides functionality to convert Qx quantum circuits into OpenQASM
  code that can be executed on real quantum hardware platforms including:

  - IBM Quantum (IBM Q)
  - AWS Braket
  - Google Cirq (via OpenQASM import)
  - Rigetti (via AWS Braket)
  - IonQ (via AWS Braket or Azure Quantum)

  Supports both OpenQASM 2.0 and 3.0 specifications.

  ## OpenQASM Versions

  - **OpenQASM 2.0**: Legacy version, widely supported, no conditional operations
  - **OpenQASM 3.0**: Modern version with conditionals, mid-circuit measurements, and control flow

  ## Supported Features

  - Single-qubit gates (H, X, Y, Z, S, T, RX, RY, RZ, Phase)
  - Multi-qubit gates (CNOT/CX, CZ, Toffoli/CCX)
  - Measurements and classical bits
  - Conditional operations (OpenQASM 3.0 only)
  - Barriers for visualization organization

  ## Examples

      # Export a Bell state circuit to OpenQASM 3.0
      circuit = Qx.circuit(2)
        |> Qx.h(0)
        |> Qx.cnot(0, 1)
        |> Qx.measure(0, 0)
        |> Qx.measure(1, 1)

      qasm = Qx.Export.OpenQASM.to_qasm(circuit)
      File.write!("bell_state.qasm", qasm)

      # Export to OpenQASM 2.0 (no conditionals)
      qasm2 = Qx.Export.OpenQASM.to_qasm(circuit, version: 2)

      # Export with custom options
      qasm = Qx.Export.OpenQASM.to_qasm(circuit,
        version: 3,
        include_comments: true,
        gate_style: :verbose
      )

  ## Platform Compatibility

  | Platform | Version | Mid-circuit Measurement | Conditionals |
  |----------|---------|------------------------|--------------|
  | IBM Quantum | 2.0, 3.0 | 3.0 only | 3.0 only |
  | AWS Braket | 3.0 | Yes | Yes |
  | Google Cirq | 2.0 | No | No |
  | Rigetti | 2.0, 3.0 | 3.0 only | 3.0 only |

  ## Limitations

  - Circuits with conditionals cannot be exported to OpenQASM 2.0
  - Custom gate definitions are expanded to standard gates
  - Qubit ordering follows MSB convention (qubit 0 is leftmost)
  """

  alias Qx.QuantumCircuit

  @doc """
  Converts a Qx quantum circuit to OpenQASM format.

  ## Parameters

    * `circuit` - A `Qx.QuantumCircuit` struct
    * `options` - Keyword list of options (default: [])

  ## Options

    * `:version` - OpenQASM version (2 or 3, default: 3)
    * `:include_comments` - Add descriptive comments (default: false)
    * `:gate_style` - Gate naming style (`:standard` or `:verbose`, default: `:standard`)

  ## Returns

  A string containing the OpenQASM program.

  ## Raises

    * `Qx.GateError` - If circuit contains unsupported gates
    * `Qx.ConditionalError` - If circuit has conditionals but version is 2
    * `ArgumentError` - If invalid options are provided

  ## Examples

      circuit = Qx.circuit(2) |> Qx.h(0) |> Qx.cnot(0, 1)
      qasm = Qx.Export.OpenQASM.to_qasm(circuit)

      # Output:
      # OPENQASM 3.0;
      # include "stdgates.inc";
      #
      # qubit[2] q;
      # bit[2] c;
      #
      # h q[0];
      # cx q[0], q[1];
  """
  def to_qasm(%QuantumCircuit{} = circuit, options \\ []) do
    version = Keyword.get(options, :version, 3)
    include_comments = Keyword.get(options, :include_comments, false)

    validate_version!(version)
    validate_circuit_for_version!(circuit, version)

    header = generate_header(version, circuit, include_comments)
    declarations = generate_declarations(circuit, version)
    instructions = generate_instructions(circuit, options)

    [header, declarations, instructions]
    |> Enum.reject(&(&1 == ""))
    |> Enum.join("\n")
  end

  # Private functions

  defp validate_version!(version) when version in [2, 3], do: :ok

  defp validate_version!(version) do
    raise ArgumentError, "Invalid OpenQASM version: #{version}. Must be 2 or 3."
  end

  defp validate_circuit_for_version!(%QuantumCircuit{instructions: instructions}, 2) do
    # Check for conditional operations which are not supported in OpenQASM 2.0
    has_conditionals? =
      Enum.any?(instructions, fn
        {:c_if, _qubits, _params} -> true
        _ -> false
      end)

    if has_conditionals? do
      raise Qx.ConditionalError,
            "Circuit contains conditional operations which are not supported in OpenQASM 2.0. Use version: 3."
    end

    :ok
  end

  defp validate_circuit_for_version!(_circuit, _version), do: :ok

  defp generate_header(version, _circuit, include_comments) do
    version_str = "#{version}.0"
    header = "OPENQASM #{version_str};"

    if include_comments do
      """
      #{header}
      // Generated by Qx - Quantum computing simulator for Elixir
      // https://github.com/your-repo/qx
      """
    else
      header
    end
  end

  defp generate_declarations(%QuantumCircuit{num_qubits: num_qubits, num_classical_bits: num_cbits}, version) do
    case version do
      3 ->
        """
        include "stdgates.inc";

        qubit[#{num_qubits}] q;
        bit[#{num_cbits}] c;
        """

      2 ->
        """
        include "qelib1.inc";

        qreg q[#{num_qubits}];
        creg c[#{num_cbits}];
        """
    end
  end

  defp generate_instructions(%QuantumCircuit{instructions: instructions}, options) do
    instructions
    |> Enum.map(&instruction_to_qasm(&1, options))
    |> Enum.join("\n")
  end

  defp instruction_to_qasm(instruction, _options) do
    case instruction do
      # Single-qubit gates
      {:h, [qubit], []} -> "h q[#{qubit}];"
      {:x, [qubit], []} -> "x q[#{qubit}];"
      {:y, [qubit], []} -> "y q[#{qubit}];"
      {:z, [qubit], []} -> "z q[#{qubit}];"
      {:s, [qubit], []} -> "s q[#{qubit}];"
      {:t, [qubit], []} -> "t q[#{qubit}];"

      # Parameterized single-qubit gates
      {:rx, [qubit], [theta]} -> "rx(#{format_param(theta)}) q[#{qubit}];"
      {:ry, [qubit], [theta]} -> "ry(#{format_param(theta)}) q[#{qubit}];"
      {:rz, [qubit], [theta]} -> "rz(#{format_param(theta)}) q[#{qubit}];"
      {:phase, [qubit], [theta]} -> "p(#{format_param(theta)}) q[#{qubit}];"

      # Two-qubit gates
      {:cx, [control, target], []} -> "cx q[#{control}], q[#{target}];"
      {:cz, [control, target], []} -> "cz q[#{control}], q[#{target}];"

      # Three-qubit gates
      {:ccx, [c1, c2, target], []} -> "ccx q[#{c1}], q[#{c2}], q[#{target}];"

      # Measurements
      {:measure, [qubit, cbit], []} -> "c[#{cbit}] = measure q[#{qubit}];"

      # Barriers
      {:barrier, qubits, []} ->
        qubit_list = Enum.map_join(qubits, ", ", &"q[#{&1}]")
        "barrier #{qubit_list};"

      # Conditional operations (OpenQASM 3.0 only)
      {:c_if, [cbit, value], conditional_instructions} ->
        # Generate QASM for all instructions in the conditional block
        conditional_qasm =
          conditional_instructions
          |> Enum.map(&instruction_to_qasm(&1, []))
          |> Enum.map(&String.trim_trailing(&1, ";"))
          |> Enum.join("; ")

        "if (c[#{cbit}] == #{value}) { #{conditional_qasm}; }"

      unsupported ->
        raise Qx.GateError, {:unsupported_gate, unsupported}
    end
  end

  defp format_param(param) when is_float(param) do
    # Format with sufficient precision, avoid scientific notation for readability
    :erlang.float_to_binary(param, decimals: 10)
    |> String.trim_trailing("0")
    |> String.trim_trailing(".")
  end

  defp format_param(param) when is_integer(param), do: "#{param}.0"
  defp format_param(param), do: "#{param}"
end
