defmodule Qx.Export.OpenQASM do
  @moduledoc """
  Export Qx quantum circuits to OpenQASM format.

  This module provides functionality to convert Qx quantum circuits into OpenQASM
  code that can be executed on real quantum hardware platforms including:

  - IBM Quantum (IBM Q)
  - AWS Braket
  - Google Cirq (via OpenQASM import)
  - Rigetti (via AWS Braket)
  - IonQ (via AWS Braket or Azure Quantum)

  Supports both OpenQASM 2.0 and 3.0 specifications.

  ## OpenQASM Versions

  - **OpenQASM 2.0**: Legacy version, widely supported, no conditional operations
  - **OpenQASM 3.0**: Modern version with conditionals, mid-circuit measurements, and control flow

  ## Supported Features

  - Single-qubit gates (H, X, Y, Z, S, T, RX, RY, RZ, Phase)
  - Multi-qubit gates (CNOT/CX, CZ, Toffoli/CCX)
  - Measurements and classical bits
  - Conditional operations (OpenQASM 3.0 only)
  - Barriers for visualization organization

  ## Examples

      # Export a Bell state circuit to OpenQASM 3.0
      circuit = Qx.circuit(2)
        |> Qx.h(0)
        |> Qx.cnot(0, 1)
        |> Qx.measure(0, 0)
        |> Qx.measure(1, 1)

      qasm = Qx.Export.OpenQASM.to_qasm(circuit)
      File.write!("bell_state.qasm", qasm)

      # Export to OpenQASM 2.0 (no conditionals)
      qasm2 = Qx.Export.OpenQASM.to_qasm(circuit, version: 2)

      # Export with custom options
      qasm = Qx.Export.OpenQASM.to_qasm(circuit,
        version: 3,
        include_comments: true,
        gate_style: :verbose
      )

  ## Platform Compatibility

  | Platform | Version | Mid-circuit Measurement | Conditionals |
  |----------|---------|------------------------|--------------|
  | IBM Quantum | 2.0, 3.0 | 3.0 only | 3.0 only |
  | AWS Braket | 3.0 | Yes | Yes |
  | Google Cirq | 2.0 | No | No |
  | Rigetti | 2.0, 3.0 | 3.0 only | 3.0 only |

  ## Limitations

  - Circuits with conditionals cannot be exported to OpenQASM 2.0
  - Custom gate definitions are expanded to standard gates
  - Qubit ordering follows MSB convention (qubit 0 is leftmost)
  """

  alias Qx.QuantumCircuit

  @doc """
  Converts a Qx quantum circuit to OpenQASM format.

  ## Parameters

    * `circuit` - A `Qx.QuantumCircuit` struct
    * `options` - Keyword list of options (default: [])

  ## Options

    * `:version` - OpenQASM version (2 or 3, default: 3)
    * `:include_comments` - Add descriptive comments (default: false)
    * `:gate_style` - Gate naming style (`:standard` or `:verbose`, default: `:standard`)

  ## Returns

  A string containing the OpenQASM program.

  ## Raises

    * `Qx.GateError` - If circuit contains unsupported gates
    * `Qx.ConditionalError` - If circuit has conditionals but version is 2
    * `ArgumentError` - If invalid options are provided

  ## Examples

      circuit = Qx.circuit(2) |> Qx.h(0) |> Qx.cnot(0, 1)
      qasm = Qx.Export.OpenQASM.to_qasm(circuit)

      # Output:
      # OPENQASM 3.0;
      # include "stdgates.inc";
      #
      # qubit[2] q;
      # bit[2] c;
      #
      # h q[0];
      # cx q[0], q[1];
  """
  def to_qasm(%QuantumCircuit{} = circuit, options \\ []) do
    version = Keyword.get(options, :version, 3)
    include_comments = Keyword.get(options, :include_comments, false)

    validate_version!(version)
    validate_circuit_for_version!(circuit, version)

    header = generate_header(version, circuit, include_comments)
    declarations = generate_declarations(circuit, version)
    instructions = generate_instructions(circuit, options)

    [header, declarations, instructions]
    |> Enum.reject(&(&1 == ""))
    |> Enum.join("\n")
  end

  # Private functions

  defp validate_version!(version) when version in [2, 3], do: :ok

  defp validate_version!(version) do
    raise ArgumentError, "Invalid OpenQASM version: #{version}. Must be 2 or 3."
  end

  defp validate_circuit_for_version!(%QuantumCircuit{instructions: instructions}, 2) do
    # Check for conditional operations which are not supported in OpenQASM 2.0
    has_conditionals? =
      Enum.any?(instructions, fn
        {:c_if, _qubits, _params} -> true
        _ -> false
      end)

    if has_conditionals? do
      raise Qx.ConditionalError,
            "Circuit contains conditional operations which are not supported in OpenQASM 2.0. Use version: 3."
    end

    :ok
  end

  defp validate_circuit_for_version!(_circuit, _version), do: :ok

  defp generate_header(version, _circuit, include_comments) do
    version_str = "#{version}.0"
    header = "OPENQASM #{version_str};"

    if include_comments do
      """
      #{header}
      // Generated by Qx - Quantum computing simulator for Elixir
      // https://github.com/your-repo/qx
      """
    else
      header
    end
  end

  defp generate_declarations(%QuantumCircuit{num_qubits: num_qubits, num_classical_bits: num_cbits}, version) do
    case version do
      3 ->
        """
        include "stdgates.inc";

        qubit[#{num_qubits}] q;
        bit[#{num_cbits}] c;
        """

      2 ->
        """
        include "qelib1.inc";

        qreg q[#{num_qubits}];
        creg c[#{num_cbits}];
        """
    end
  end

  defp generate_instructions(%QuantumCircuit{instructions: instructions}, options) do
    Enum.map_join(instructions, "\n", &instruction_to_qasm(&1, options))
  end

  # credo:disable-for-next-line Credo.Check.Refactor.CyclomaticComplexity
  defp instruction_to_qasm(instruction, _options) do
    case instruction do
      {:h, qubits, params} -> single_qubit_gate_to_qasm("h", qubits, params)
      {:x, qubits, params} -> single_qubit_gate_to_qasm("x", qubits, params)
      {:y, qubits, params} -> single_qubit_gate_to_qasm("y", qubits, params)
      {:z, qubits, params} -> single_qubit_gate_to_qasm("z", qubits, params)
      {:s, qubits, params} -> single_qubit_gate_to_qasm("s", qubits, params)
      {:t, qubits, params} -> single_qubit_gate_to_qasm("t", qubits, params)
      {:rx, qubits, params} -> parametric_gate_to_qasm("rx", qubits, params)
      {:ry, qubits, params} -> parametric_gate_to_qasm("ry", qubits, params)
      {:rz, qubits, params} -> parametric_gate_to_qasm("rz", qubits, params)
      {:phase, qubits, params} -> parametric_gate_to_qasm("p", qubits, params)
      {:cx, qubits, params} -> two_qubit_gate_to_qasm("cx", qubits, params)
      {:cz, qubits, params} -> two_qubit_gate_to_qasm("cz", qubits, params)
      {:ccx, [c1, c2, target], []} -> "ccx q[#{c1}], q[#{c2}], q[#{target}];"
      {:measure, [qubit, cbit], []} -> "c[#{cbit}] = measure q[#{qubit}];"
      {:barrier, qubits, []} -> barrier_to_qasm(qubits)
      {:c_if, [cbit, value], conditional_instructions} -> conditional_to_qasm(cbit, value, conditional_instructions)
      unsupported -> raise Qx.GateError, {:unsupported_gate, unsupported}
    end
  end

  defp single_qubit_gate_to_qasm(gate_name, [qubit], []) do
    "#{gate_name} q[#{qubit}];"
  end

  defp parametric_gate_to_qasm(gate_name, [qubit], [theta]) do
    "#{gate_name}(#{format_param(theta)}) q[#{qubit}];"
  end

  defp two_qubit_gate_to_qasm(gate_name, [control, target], []) do
    "#{gate_name} q[#{control}], q[#{target}];"
  end

  defp barrier_to_qasm(qubits) do
    qubit_list = Enum.map_join(qubits, ", ", &"q[#{&1}]")
    "barrier #{qubit_list};"
  end

  defp conditional_to_qasm(cbit, value, conditional_instructions) do
    conditional_qasm =
      Enum.map_join(
        conditional_instructions,
        "; ",
        &(&1 |> instruction_to_qasm([]) |> String.trim_trailing(";"))
      )

    "if (c[#{cbit}] == #{value}) { #{conditional_qasm}; }"
  end

  defp format_param(param) when is_float(param) do
    # Format with sufficient precision, avoid scientific notation for readability
    :erlang.float_to_binary(param, decimals: 10)
    |> String.trim_trailing("0")
    |> String.trim_trailing(".")
  end

  defp format_param(param) when is_integer(param), do: "#{param}.0"
  defp format_param(param), do: "#{param}"
end
